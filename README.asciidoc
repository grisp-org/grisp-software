GRISP
=====
:toc:

== Prerequisites

- the +waf+ build tools needs to be installed and in path (see
  https://git.rtems.org/rtems-libbsd/tree/README.waf)
- the +xz+ decompression tool needs to be installed and because of a bug in the
  buildsystem its expected in +/usr/local/bin/xz+
- the +zlib+ development files are necessary
- to check for some of RTEMS source builders prerequisites (but read Issue #7 before)
    
    cd rtems-source-builder
    ./source-builder/sb-check

== Quick Start Guide

You can build the whole toolchain by running +./build/build.sh+. See
<<Building>> for more details.

To build the simple RTEMS sample application, go to +grisp-simple-sample+ and
call +make+.

If you want to use OpenOCD, you have to make sure that you have read and write
access to the USB device. On a Linux system using udev, you can copy the
udev-rule from build/99-grisp.rule to /etc/udev/rules.d/ for that. The rule also
provides a fixed name for the serial console (/dev/ttyGRiSP).

== Directory Structure

The following directory structure is used in this project:

- build: scripts for building the tool chain and libraries
- grisp-XYZ: applications
- libXYZ: non-RTEMS libraries
- rtems-XYZ: software and libraries related to RTEMS
- README.asciidoc: this document

== Building

The complete toolchain is built by running +./build/build.sh+. This will do the
following:

- check out the necessary git submodules
- bootstrap RTEMS
- build and install the toolchain
- build and install the RTEMS BSP
- build and install necessary libs

All installations are made inside the +rtems-install+ subdirectory in the base
directory of the repository. To change the install location edit the +PREFIX+ in
+build/configuration.sh+.

=== Cleaning

Normally, running `./build/build.sh` (or any other of the individual build
scripts in the `./build` folder) should rebuild without the need for cleaning.

However, if you want a clean start you can delete the `rtems-install` folder
which will delete all created binaries, libraries and header files.

To make a complete reset of the whole repository, use the following commands:

[source,shell]
----
git co .        # Reverts all uncommited changes
git clean -dxn  # gives a preview, what unversioned files would be deleted
git clean -dxf  # deletes everything that is not under version control
----

== Boot Loader

The boot loader will try to initialize and mount the SD card. In case this is
successful it tries to read the +grisp.ini+ configuration file from the SD root
directory.

Sample grisp.ini (showing the default values):
[source,ini]
----
[boot]
timeout_in_seconds = 3
image_path = /media/mmcsd-0-0/grisp.bin
----

All values are optional and in case something is missing default values will be
used (presented in the listing above). Once the timeout expired without user
input the automatic application load sequence starts.

== Debugging

It is possible to debug an application using the on-board FTDI to SWD adapter.
First build and install OpenOCD by running `./build/build-openocd.sh`.

Place a SD with some sample application into the target. This takes care that
the bootloader starts an application. The debug scripts will wait for this and
then overwrite the application that is booted by the bootloader with the one
that should be debugged.

After that you should start openocd on one console using
`./build/debug-start-openocd.sh`. This starts an GDB-Server. Do not terminate
the process. You can then start a gdb that connects to the server using
`./build/debug-start-gdb.sh path/to/app.exe`. The script adds a `reset` command
to the normal gdb that restarts the target and reloads the application. Note
that for bigger applications, that might need quite some time.
